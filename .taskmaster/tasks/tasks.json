{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Spoke Initialization & Structural Alignment",
        "description": "Align the existing boilerplate structure with setup.py requirements and define strict dependency constraints.",
        "details": "The directory 'flashcore-lib' already exists but must be renamed to 'flashcore' to match setup.py expectations (line 34: version=read('flashcore', 'VERSION')). Update requirements.txt to exclude torch/fsrs-optimizer and include only lightweight runtime dependencies: fsrs>=3.0.0, duckdb>=1.0.0, pydantic>=2.7.0, typer>=0.12.0, rich>=13.0.0, ruamel.yaml>=0.17.0. This enforces the 'Nuclear Reactor' fix from PRD Section 2.A.",
        "testStrategy": "Verify the repository structure and ensure all dependencies are correctly listed in pyproject.toml.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Rename Package Directory",
            "description": "Rename 'flashcore-lib' to 'flashcore' to match setup.py package name.",
            "dependencies": [],
            "details": "Execute: mv flashcore-lib flashcore. This fixes the mismatch where setup.py expects 'flashcore' (line 34) but the directory is named 'flashcore-lib'.",
            "status": "pending",
            "testStrategy": "Verify directory exists at ./flashcore/ and setup.py can read VERSION file."
          },
          {
            "id": 2,
            "title": "Enforce Dependency Constraints (Nuclear Reactor Fix)",
            "description": "Update requirements.txt to exclude heavy ML dependencies and include only lightweight runtime deps.",
            "dependencies": [
              1
            ],
            "details": "Edit requirements.txt to contain ONLY: duckdb>=1.0.0, pydantic>=2.7.0, fsrs>=3.0.0 (NOT fsrs-optimizer), typer>=0.12.0, rich>=13.0.0, ruamel.yaml>=0.17.0. CRITICAL: Exclude torch, transformers, fsrs-optimizer per PRD Section 2.A.",
            "status": "pending",
            "testStrategy": "Run 'pip install -r requirements.txt' and verify no torch/transformers in dependency tree via 'pip list | grep torch'."
          },
          {
            "id": 3,
            "title": "Establish Modern Build System and Deprecate Legacy Setup",
            "description": "Create pyproject.toml as single source of truth and deprecate setup.py.",
            "dependencies": [
              2
            ],
            "details": "Create pyproject.toml with [project] name='flashcore', version from VERSION file, requires-python='>=3.10', and dependencies matching requirements.txt. Add [build-system] using setuptools. CRITICAL: After creating pyproject.toml, rename setup.py to setup.py.bak or remove it entirely to prevent build tool confusion. Modern Python packaging (PEP 517/518) uses pyproject.toml as the single source of truth. Having both files creates ambiguity about which defines dependencies and metadata.",
            "status": "pending",
            "testStrategy": "Validate with 'python -m build --sdist' and inspect generated metadata. Verify setup.py does not exist or is renamed to .bak."
          },
          {
            "id": 4,
            "title": "Verify No Heavy Dependencies in Tree",
            "description": "Audit the full dependency tree to ensure no transitive heavy dependencies.",
            "dependencies": [
              3
            ],
            "details": "Run 'pip install -e .' then 'pip list' and verify total install size <50MB. Use 'pipdeptree' to check for torch/transformers in transitive deps.",
            "status": "pending",
            "testStrategy": "PRD Section 5 Checklist Item 1: 'uv tree shows NO torch, transformers, or fsrs-optimizer'."
          },
          {
            "id": 5,
            "title": "Create .gitignore for Python Package",
            "description": "Add .gitignore to exclude build artifacts and virtual environments.",
            "dependencies": [
              4
            ],
            "details": "Create .gitignore with: __pycache__/, *.pyc, *.pyo, *.egg-info/, dist/, build/, .venv/, .pytest_cache/, .coverage.",
            "status": "pending",
            "testStrategy": "Verify build artifacts are not tracked by git status."
          }
        ]
      },
      {
        "id": 2,
        "title": "Migrate Core Data Models",
        "description": "Transfer and refactor core data models from HPE_ARCHIVE to the new library structure.",
        "details": "Copy HPE_ARCHIVE/flashcore/card.py to flashcore/models.py. This file contains Card, Review, Session, and CardState models using Pydantic v2. Remove all imports referencing 'cultivation.scripts.flashcore' and replace with relative imports (e.g., 'from .db import ...'). Ensure Pydantic v2 syntax is maintained (Field, model_validate, model_dump). PRD Phase 2 Step 1.",
        "testStrategy": "Import models.py and instantiate Card/Review objects. Run 'python -c \"from flashcore.models import Card, Review, Session, CardState\"' to verify no import errors.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Copy card.py to models.py",
            "description": "Transfer the Card, Review, Session, and CardState models from HPE_ARCHIVE.",
            "dependencies": [],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/card.py flashcore/models.py. This is the foundation data layer.",
            "status": "pending",
            "testStrategy": "Verify file exists at flashcore/models.py."
          },
          {
            "id": 2,
            "title": "Remove Cultivation Import References",
            "description": "Replace absolute imports with relative imports for library portability.",
            "dependencies": [
              1
            ],
            "details": "Search for 'from cultivation.scripts.flashcore' in models.py and replace with relative imports. Example: 'from cultivation.scripts.flashcore.config import X' becomes 'from .config import X' or remove if not needed.",
            "status": "pending",
            "testStrategy": "Run 'grep -n cultivation flashcore/models.py' should return no results."
          },
          {
            "id": 3,
            "title": "Verify Pydantic v2 Compatibility",
            "description": "Ensure all Pydantic models use v2 syntax (no deprecated v1 patterns).",
            "dependencies": [
              2
            ],
            "details": "Check for: Field() usage, model_validate() instead of parse_obj(), model_dump() instead of dict(). Verify ConfigDict is used instead of class Config.",
            "status": "pending",
            "testStrategy": "Run models through pydantic validation: 'python -c \"from flashcore.models import Card; Card.model_validate({...})\"'."
          },
          {
            "id": 4,
            "title": "Add Type Hints and Documentation",
            "description": "Ensure all models have complete type hints and docstrings.",
            "dependencies": [
              3
            ],
            "details": "Verify Card, Review, Session classes have docstrings explaining their purpose. Ensure all fields have type annotations.",
            "status": "pending",
            "testStrategy": "Run mypy on models.py: 'mypy flashcore/models.py --strict'."
          },
          {
            "id": 5,
            "title": "Extract FSRS Constants to constants.py",
            "description": "Transfer FSRS algorithm constants from HPE_ARCHIVE config.py.",
            "dependencies": [
              4
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/config.py flashcore/constants.py. CRITICAL: Remove Settings class and all path defaults (db_path, yaml_source_dir, assets_dir, export_dir, user_uuid) - these violate DI pattern. KEEP ONLY: DEFAULT_PARAMETERS (lines 58-80) and DEFAULT_DESIRED_RETENTION (line 83). Rename file to constants.py (not config.py) to accurately reflect content - this file contains static FSRS algorithm parameters, not runtime configuration. PURITY CONSTRAINT: Ensure constants.py does NOT import pydantic, pydantic_settings, os, or pathlib. It must be a pure Python file containing only native types (Tuple, float) to prevent circular imports during the O(1) scheduler refactor. Remove lines 4-8 (Path, uuid, pydantic_settings imports). Only keep 'from typing import Tuple' if needed.",
            "status": "pending",
            "testStrategy": "Verify flashcore/constants.py exists and contains only DEFAULT_PARAMETERS and DEFAULT_DESIRED_RETENTION. Run 'grep -n Settings flashcore/constants.py' should return no results. Run 'grep -n import flashcore/constants.py' should show only 'from typing import Tuple' or no imports."
          },
          {
            "id": 6,
            "title": "Create __init__.py Exports",
            "description": "Expose models in flashcore/__init__.py for clean imports.",
            "dependencies": [
              5
            ],
            "details": "Add to flashcore/__init__.py: 'from .models import Card, Review, Session, CardState, ReviewRating'. This allows 'from flashcore import Card'.",
            "status": "pending",
            "testStrategy": "Test import: 'python -c \"from flashcore import Card, Review\"'."
          },
          {
            "id": 7,
            "title": "Migrate Model Tests (Incremental Verification)",
            "description": "Copy and adapt test_card.py to verify models work correctly.",
            "dependencies": [
              6
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_card.py tests/test_models.py. Update imports from 'cultivation.scripts.flashcore.card' to 'flashcore.models'. Verify Pydantic v2 validation works (model_validate, model_dump). Run 'pytest tests/test_models.py -v' - all tests should pass. This provides immediate safety net for model refactoring.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_models.py -v' - all model tests pass. Verify Card, Review, Session instantiation and validation."
          }
        ]
      },
      {
        "id": 3,
        "title": "Refactor Database Layer for Dependency Injection",
        "description": "Modify the database layer to eliminate hardcoded paths and enforce dependency injection.",
        "details": "Copy HPE_ARCHIVE/flashcore/database.py, connection.py, schema_manager.py, db_utils.py to flashcore/db.py (consolidate into single module). CRITICAL REFACTOR (PRD Section 2.B): FlashcardDatabase.__init__ currently accepts Optional[db_path] and defaults to config.settings (line 44). Change signature to REQUIRE db_path: 'def __init__(self, db_path: Union[str, Path], read_only: bool = False)'. Remove all references to config.settings. This enforces the 'Hardcoded Life' fix.",
        "testStrategy": "Instantiate FlashcardDatabase without db_path argument - should raise TypeError. Instantiate with explicit path - should succeed. Run: 'python -c \"from flashcore.db import FlashcardDatabase; FlashcardDatabase()\"' should fail.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Database Package Structure",
            "description": "Port database subsystem to flashcore/db/ package maintaining separation of concerns.",
            "dependencies": [],
            "details": "Create directory: mkdir -p flashcore/db. Copy modules: cp HPE_ARCHIVE/flashcore/database.py flashcore/db/database.py; cp HPE_ARCHIVE/flashcore/connection.py flashcore/db/connection.py; cp HPE_ARCHIVE/flashcore/schema_manager.py flashcore/db/schema_manager.py; cp HPE_ARCHIVE/flashcore/db_utils.py flashcore/db/db_utils.py; cp HPE_ARCHIVE/flashcore/schema.py flashcore/db/schema.py. Create flashcore/db/__init__.py that exports: 'from .database import FlashcardDatabase'. This maintains architectural separation (4 focused modules totaling 1089 lines) rather than creating a monolithic 1000+ line file.",
            "status": "pending",
            "testStrategy": "Verify flashcore/db/ directory exists with 5 modules. Verify flashcore/db/__init__.py exports FlashcardDatabase."
          },
          {
            "id": 2,
            "title": "Remove config.settings Dependency",
            "description": "Eliminate all imports and references to config.settings from db package modules.",
            "dependencies": [
              1
            ],
            "details": "In flashcore/db/database.py line 44, __init__ has 'db_path: Optional[Union[str, Path]] = None' and defaults to settings. Remove this default. In flashcore/db/connection.py line 6, remove 'from .config import settings' import and line 16 'self.db_path_resolved = settings.db_path'. The library must not know about config files.",
            "status": "pending",
            "testStrategy": "Run 'grep -rn config flashcore/db/' should return no results."
          },
          {
            "id": 3,
            "title": "Make db_path Required Argument",
            "description": "Change FlashcardDatabase.__init__ signature to require db_path.",
            "dependencies": [
              2
            ],
            "details": "Change signature from 'def __init__(self, db_path: Optional[Union[str, Path]] = None, ...)' to 'def __init__(self, db_path: Union[str, Path], read_only: bool = False)'. Update docstring to reflect this is now required.",
            "status": "pending",
            "testStrategy": "Attempt to instantiate without argument: 'FlashcardDatabase()' should raise TypeError: missing required positional argument 'db_path'."
          },
          {
            "id": 4,
            "title": "Update ConnectionHandler for DI",
            "description": "Ensure ConnectionHandler also requires db_path and doesn't default to config.",
            "dependencies": [
              3
            ],
            "details": "Review ConnectionHandler.__init__ in connection.py. If it also has Optional db_path with config default, apply same refactor. Ensure it receives db_path from FlashcardDatabase.",
            "status": "pending",
            "testStrategy": "Trace db_path flow: FlashcardDatabase -> ConnectionHandler -> duckdb.connect(). No config lookups in chain."
          },
          {
            "id": 5,
            "title": "Add db Package to __init__.py Exports",
            "description": "Expose FlashcardDatabase from db package in flashcore/__init__.py.",
            "dependencies": [
              4
            ],
            "details": "Add to flashcore/__init__.py: 'from .db import FlashcardDatabase'. The db/__init__.py already exports FlashcardDatabase from .database, so this import works cleanly. This allows 'from flashcore import FlashcardDatabase'.",
            "status": "pending",
            "testStrategy": "Test import and instantiation: 'python -c \"from flashcore import FlashcardDatabase; db = FlashcardDatabase(\"/tmp/test.db\")\"'."
          },
          {
            "id": 6,
            "title": "Migrate Database Tests with DI Fixtures (Incremental Verification)",
            "description": "Copy and adapt test_database.py to verify DI refactoring works correctly.",
            "dependencies": [
              5
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_database.py tests/test_db.py. CRITICAL FIXTURE UPDATE: Replace all fixtures that use 'FlashcardDatabase()' with 'FlashcardDatabase(db_path=tmp_path / \"test.db\")'. Update conftest.py to provide tmp_path fixture. Update imports from 'cultivation.scripts.flashcore' to 'flashcore'. This verifies Dependency Injection works and provides safety net for DB refactoring. Also copy test_database_errors.py for error handling tests.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_db.py -v' - all database tests pass with explicit db_path. Verify FlashcardDatabase() without args raises TypeError."
          }
        ]
      },
      {
        "id": 4,
        "title": "Optimize Scheduler Logic (O(1) Performance Fix)",
        "description": "Eliminate the O(N) history replay bottleneck by using cached card state.",
        "details": "CRITICAL PERFORMANCE FIX (PRD Section 2 Finding 2): HPE_ARCHIVE/flashcore/scheduler.py lines 154-160 contain 'for review in history: fsrs_card, _ = self.fsrs_scheduler.review_card(...)' - this replays ENTIRE history on every review (O(N) complexity). For a card with 500 reviews, this loops 500 times. SOLUTION: Change compute_next_state signature from 'compute_next_state(history: List[Review], ...)' to 'compute_next_state(card: Card, new_rating: int, ...)'. Initialize FSRSCard from card.stability, card.difficulty, card.state (cached values) instead of replaying history. This makes scheduling O(1).",
        "testStrategy": "Create card with 100 reviews. Time compute_next_state - should be <10ms regardless of history length. Compare before/after: old implementation time should scale with history length, new should be constant.",
        "priority": "critical",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Copy scheduler.py and Update Imports",
            "description": "Transfer the scheduler module from HPE_ARCHIVE and update imports to use constants.py.",
            "dependencies": [],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/scheduler.py flashcore/scheduler.py. This contains FSRS_Scheduler and BaseScheduler classes. CRITICAL: Update imports on lines 16-19 from 'from cultivation.scripts.flashcore.config import DEFAULT_PARAMETERS, DEFAULT_DESIRED_RETENTION' to 'from .constants import DEFAULT_PARAMETERS, DEFAULT_DESIRED_RETENTION'. This reflects the config.py â†’ constants.py rename for clarity.",
            "status": "pending",
            "testStrategy": "Verify file exists at flashcore/scheduler.py. Run 'grep -n \"from.*constants import\" flashcore/scheduler.py' - should find import on line ~16."
          },
          {
            "id": 2,
            "title": "Change compute_next_state Signature",
            "description": "Modify method to accept Card object instead of history list.",
            "dependencies": [
              1
            ],
            "details": "In scheduler.py line 147, change 'def compute_next_state(self, history: List[Review], new_rating: int, review_ts: datetime.datetime)' to 'def compute_next_state(self, card: Card, new_rating: int, review_ts: datetime.datetime)'. Update BaseScheduler abstract method signature too (line 53).",
            "status": "pending",
            "testStrategy": "Verify signature matches: 'grep -A2 \"def compute_next_state\" flashcore/scheduler.py'."
          },
          {
            "id": 3,
            "title": "Copy review_processor.py to flashcore/services.py",
            "description": "Transfer the ReviewProcessor service module from HPE_ARCHIVE.",
            "dependencies": [
              2
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/review_processor.py flashcore/services.py. This contains ReviewProcessor class that orchestrates scheduler and database for review operations. Also copy review_manager.py and session_manager.py if needed for service layer.",
            "status": "pending",
            "testStrategy": "Verify file exists at flashcore/services.py and contains ReviewProcessor class."
          },
          {
            "id": 4,
            "title": "Remove History Replay Loop (O(N) -> O(1))",
            "description": "Delete the for loop that replays entire review history.",
            "dependencies": [
              3
            ],
            "details": "Delete lines 154-160 in scheduler.py: 'fsrs_card = FSRSCard()' followed by 'for review in history: ...' loop. This is the performance bottleneck.",
            "status": "pending",
            "testStrategy": "Verify no 'for review in history' loop exists in compute_next_state method."
          },
          {
            "id": 5,
            "title": "Initialize FSRSCard from Cached Card State",
            "description": "Use card.stability, card.difficulty, card.state instead of replaying history.",
            "dependencies": [
              4
            ],
            "details": "Replace deleted loop with: 'fsrs_card = FSRSCard(); if card.state != CardState.New: fsrs_card.stability = card.stability; fsrs_card.difficulty = card.difficulty; fsrs_card.state = FSRSState(card.state.value); fsrs_card.due = card.next_due_date'. This initializes from cached state (O(1)).",
            "status": "pending",
            "testStrategy": "Verify fsrs_card is initialized from card attributes, not history loop."
          },
          {
            "id": 6,
            "title": "Update services.py to Pass Card Object",
            "description": "Modify callers of compute_next_state to pass card instead of history.",
            "dependencies": [
              5
            ],
            "details": "In services.py (review_processor.py) line 103, change 'scheduler_output = self.scheduler.compute_next_state(history=review_history, ...)' to 'scheduler_output = self.scheduler.compute_next_state(card=card, ...)'. Remove history parameter.",
            "status": "pending",
            "testStrategy": "Run tests to verify scheduler integration works with new signature."
          },
          {
            "id": 7,
            "title": "Migrate Scheduler Tests with O(1) Benchmark (Incremental Verification)",
            "description": "Copy and adapt test_scheduler.py to verify O(1) optimization works correctly.",
            "dependencies": [
              6
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_scheduler.py tests/test_scheduler.py. Update imports from 'cultivation.scripts.flashcore' to 'flashcore'. CRITICAL: Add new benchmark test 'test_compute_next_state_is_constant_time' that creates cards with 1, 10, 100, 500 reviews and times compute_next_state for each. Assert that time difference between 1 and 500 reviews is <50ms (proving O(1) not O(N)). This verifies the performance fix works.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_scheduler.py -v' - all tests pass. Run benchmark test - verify O(1) performance (constant time regardless of history length)."
          }
        ]
      },
      {
        "id": 5,
        "title": "Refactor Parser Layer to be Stateless",
        "description": "Remove stateful logic from the parser and centralize deduplication checks.",
        "details": "STATELESS REFACTOR (PRD Section 2 Finding 3): HPE_ARCHIVE/flashcore/yaml_processing/yaml_processor.py line 40 contains 'self.seen_questions: Dict[str, Path] = {}' - this is ephemeral state that creates split-brain deduplication. The YAMLProcessor should be a pure function: File -> List[Card]. Remove self.seen_questions entirely. Move ALL deduplication logic to the CLI ingest command, which should query db.get_all_card_fronts_and_uuids() BEFORE processing to get authoritative list, then filter YAMLProcessor output against this list.",
        "testStrategy": "Instantiate YAMLProcessor, call process_file() twice on same file - should return identical results (no state carried between calls). Verify 'grep -n seen_questions flashcore/parser.py' returns no results.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Copy yaml_processor.py to flashcore/parser.py",
            "description": "Transfer the YAML processing module from HPE_ARCHIVE.",
            "dependencies": [],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/yaml_processing/yaml_processor.py flashcore/parser.py. Also copy yaml_models.py if it contains necessary Pydantic models for YAML validation.",
            "status": "pending",
            "testStrategy": "Verify file exists at flashcore/parser.py."
          },
          {
            "id": 2,
            "title": "Remove self.seen_questions State Variable",
            "description": "Delete the stateful seen_questions dictionary from YAMLProcessor.__init__.",
            "dependencies": [
              1
            ],
            "details": "In parser.py line 40, delete 'self.seen_questions: Dict[str, Path] = {}'. Also remove all references to self.seen_questions in _handle_processed_card method (lines 99-110). The parser should not track duplicates.",
            "status": "pending",
            "testStrategy": "Verify 'grep -n seen_questions flashcore/parser.py' returns no results."
          },
          {
            "id": 3,
            "title": "Add parser.py to __init__.py Exports",
            "description": "Expose YAMLProcessor in flashcore/__init__.py.",
            "dependencies": [
              2
            ],
            "details": "Add to flashcore/__init__.py: 'from .parser import YAMLProcessor, YAMLProcessorConfig'. This allows 'from flashcore import YAMLProcessor'.",
            "status": "pending",
            "testStrategy": "Test import: 'python -c \"from flashcore import YAMLProcessor\"'."
          },
          {
            "id": 4,
            "title": "Migrate Parser Tests with Statelessness Verification (Incremental Verification)",
            "description": "Copy and adapt test_yaml_processor.py to verify parser is truly stateless.",
            "dependencies": [
              3
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_yaml_processor.py tests/test_parser.py. Update imports from 'cultivation.scripts.flashcore.yaml_processing' to 'flashcore.parser'. CRITICAL: Add new test 'test_parser_is_stateless' that instantiates YAMLProcessor, processes a file twice, and verifies identical output (no state carried between calls). Also test that processing file with duplicate fronts returns all cards (no internal filtering). This verifies stateless refactor works.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_parser.py -v' - all tests pass. Run statelessness test - verify parser has no memory between calls."
          }
        ]
      },
      {
        "id": 6,
        "title": "Develop CLI Package for flashcore",
        "description": "Reconstruct the CLI as a modular package maintaining separation of concerns.",
        "details": "Port HPE_ARCHIVE/flashcore/cli/ as flashcore/cli/ PACKAGE (not single file). HPE_ARCHIVE has 6 modules totaling 960 lines: main.py (382 lines - entry point), review_ui.py (93 lines - UI), _review_logic.py (28 lines), _review_all_logic.py (172 lines), _vet_logic.py (222 lines - ingest), _export_logic.py (63 lines). Preserve this modular structure to avoid creating a 'God Object'. CRITICAL (PRD Section 3.3): CLI must accept --db flag for database path (no defaults). The CLI is responsible for dependency injection - it receives paths from user and passes to library classes.",
        "testStrategy": "Run 'flashcore review --db=/tmp/test.db --deck=test' - should work. Run 'flashcore review' without --db - should show error requiring db path.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CLI Package Structure",
            "description": "Set up flashcore/cli/ as a package with modular architecture.",
            "dependencies": [],
            "details": "Create directory: mkdir -p flashcore/cli. Copy modular structure: cp HPE_ARCHIVE/flashcore/cli/main.py flashcore/cli/main.py (entry point); cp HPE_ARCHIVE/flashcore/cli/review_ui.py flashcore/cli/review_ui.py (UI layer); cp HPE_ARCHIVE/flashcore/cli/__init__.py flashcore/cli/__init__.py. This preserves separation of concerns - main.py handles CLI routing, separate modules handle business logic. Update imports from 'cultivation.scripts.flashcore' to 'flashcore'.",
            "status": "pending",
            "testStrategy": "Verify flashcore/cli/ directory exists with main.py and __init__.py. Run 'python -m flashcore.cli.main --help' - should show commands."
          },
          {
            "id": 2,
            "title": "Extract and Refactor Ingestion Logic with Authoritative Deduplication",
            "description": "Extract ingestion and upsert logic from legacy main.py and implement DB-based deduplication.",
            "dependencies": [
              1
            ],
            "details": "CRITICAL SOURCE CORRECTION: Ingestion logic is in HPE_ARCHIVE/flashcore/cli/main.py lines 65-161 (_load_cards_from_source, _filter_new_cards, _execute_ingestion, _perform_ingestion_logic). Create flashcore/cli/ingest.py module extracting these functions. REFACTOR DEDUPLICATION (from Task 5.3): Replace _filter_new_cards logic to call db.get_all_card_fronts_and_uuids() BEFORE YAMLProcessor, filter output against existing_fronts set, then upsert only new cards. NOTE: _vet_logic.py (222 lines) is for 'vet' command (validation/formatting), NOT ingestion - copy separately if vet command needed.",
            "status": "pending",
            "testStrategy": "Ingest same deck twice - second run should detect all cards as duplicates and insert 0 new cards. Verify db.get_all_card_fronts_and_uuids() called before processing."
          },
          {
            "id": 3,
            "title": "Port Review Logic Modules",
            "description": "Copy review logic modules maintaining separation between orchestration and UI.",
            "dependencies": [
              1
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/cli/_review_logic.py flashcore/cli/_review_logic.py (28 lines - session orchestration); cp HPE_ARCHIVE/flashcore/cli/_review_all_logic.py flashcore/cli/_review_all_logic.py (172 lines - multi-deck logic). Update imports to 'flashcore'. Wire up: FlashcardDatabase(db_path=args.db), FSRS_Scheduler, ReviewSessionManager. Pass all paths explicitly - no config.settings references. Connect to review_ui.py for presentation layer.",
            "status": "pending",
            "testStrategy": "Run 'flashcore review --db=/tmp/test.db --deck=test' - should start review session."
          },
          {
            "id": 4,
            "title": "Port Export, Vet, and Stats Functionality",
            "description": "Copy remaining CLI modules for export, vet, and stats commands.",
            "dependencies": [
              1
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/cli/_export_logic.py flashcore/cli/_export_logic.py (63 lines - export functionality); cp HPE_ARCHIVE/flashcore/cli/_vet_logic.py flashcore/cli/_vet_logic.py (222 lines - YAML validation/formatting for 'vet' command, NOT ingestion). Add stats command logic to main.py (query database for card counts, review stats, due cards). Display with rich tables. Update all imports to 'flashcore'.",
            "status": "pending",
            "testStrategy": "Run 'flashcore stats --db=/tmp/test.db' - should display deck statistics. Run 'flashcore vet' - should validate YAML files."
          },
          {
            "id": 5,
            "title": "Add CLI to __main__.py Entry Point",
            "description": "Wire CLI to package entry point for 'flashcore' command.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Update flashcore/__main__.py to import and run CLI app. Ensure setup.py entry_points references this. Test that 'flashcore' command is available after pip install.",
            "status": "pending",
            "testStrategy": "After 'pip install -e .', run 'which flashcore' - should find command. Run 'flashcore --help' - should work."
          }
        ]
      },
      {
        "id": 7,
        "title": "Migrate Integration and Architectural Regression Tests",
        "description": "Transfer integration tests and architectural regression tests to verify end-to-end functionality.",
        "details": "Since unit tests are now migrated incrementally (Tasks 2-5), this task focuses on: (1) CLI Integration Tests - copy HPE_ARCHIVE/tests/cli/ to tests/cli/ for end-to-end CLI command testing. (2) Architectural Regression Tests - copy test_rating_system_inconsistency.py, test_session_analytics_gaps.py, test_review_logic_duplication.py (PRD Section 4 Phase 2 Step 5 calls these 'high-value assets' documenting past flaws). (3) Service Layer Tests - copy test_review_processor.py, test_review_manager.py, test_session_manager.py. Update all imports from 'cultivation.scripts.flashcore' to 'flashcore'. Update fixtures to use explicit db_path.",
        "testStrategy": "Run 'pytest tests/ -v' - all tests pass including integration and regression tests. Verify test coverage >80% with 'pytest --cov=flashcore tests/'. Run CLI integration tests to verify end-to-end workflows.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Migrate CLI Integration Tests",
            "description": "Copy CLI integration tests to verify end-to-end command functionality.",
            "dependencies": [],
            "details": "Execute: cp -r HPE_ARCHIVE/tests/cli/ tests/cli/. These tests verify the full CLI workflow (ingest, review, stats commands). Update imports and ensure tests use explicit --db flags (no config.settings).",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/cli/ -v' - all CLI integration tests pass."
          },
          {
            "id": 2,
            "title": "Migrate Architectural Regression Tests",
            "description": "Copy tests that document and prevent past architectural flaws.",
            "dependencies": [],
            "details": "Copy: test_rating_system_inconsistency.py, test_session_analytics_gaps.py, test_review_logic_duplication.py. PRD emphasizes these are 'invaluable architectural regression tests' that validate fixes for past bugs. Update imports to 'flashcore'.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_rating_system_inconsistency.py tests/test_session_analytics_gaps.py -v' - all regression tests pass."
          },
          {
            "id": 3,
            "title": "Migrate Service Layer Tests",
            "description": "Copy tests for ReviewProcessor, ReviewManager, SessionManager.",
            "dependencies": [],
            "details": "Copy: test_review_processor.py, test_review_manager.py, test_session_manager.py, test_session_model.py. These test the service orchestration layer. Update imports to 'flashcore.services'.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_review_processor.py tests/test_review_manager.py -v' - all service tests pass."
          },
          {
            "id": 4,
            "title": "Copy conftest.py and Shared Fixtures",
            "description": "Migrate shared test fixtures and configuration.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Copy HPE_ARCHIVE/tests/conftest.py to tests/conftest.py. Update fixtures to use explicit db_path (tmp_path / 'test.db') instead of config.settings. Ensure pytest configuration is correct.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/ --collect-only' - all tests discovered correctly with proper fixtures."
          },
          {
            "id": 5,
            "title": "Run Full Test Suite and Verify Coverage",
            "description": "Execute complete test suite and verify coverage meets PRD requirements.",
            "dependencies": [
              4
            ],
            "details": "Run 'pytest tests/ -v' to execute all tests (unit + integration + regression). Run 'pytest --cov=flashcore tests/' to verify >80% coverage. All tests should pass, proving the refactoring is correct and safe.",
            "status": "pending",
            "testStrategy": "All tests pass. Coverage >80%. No regressions detected."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Data Safety Strategy",
        "description": "Develop a strategy for safely migrating data from the old system to the new library.",
        "details": "PRD Section 4 Phase 3: Do NOT copy .db file directly (binary compatibility risk). Instead: (1) Create export script HPE_ARCHIVE/dump_history.py (in legacy environment) that runs against the old DB and exports cards -> cards.json, reviews -> reviews.json. (2) Create flashcore/scripts/migrate.py (in new library utility folder, NOT core package) with import_from_json(cards_path, reviews_path, db_path) that recreates schema and inserts data. (3) Validation: Compare row counts between old and new DBs. CRITICAL SEPARATION: dump_history.py lives in HPE_ARCHIVE (legacy), migrate.py lives in flashcore/scripts/ (new utility). Do not put migration scripts in core flashcore package logic to avoid polluting the library.",
        "testStrategy": "Export from old DB using HPE_ARCHIVE/dump_history.py, import to new DB using flashcore/scripts/migrate.py, verify: SELECT COUNT(*) FROM cards matches, SELECT COUNT(*) FROM reviews matches. Spot-check card UUIDs exist in both DBs.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Finalize and Document Migration",
        "description": "Complete the migration process and document the new architecture and usage.",
        "details": "CRITICAL (PRD Section 4 Feature Branch Workflow): Remove HPE_ARCHIVE/ directory before final merge. Execute: 'git rm -r HPE_ARCHIVE/' and commit with message 'chore(repo): Remove HPE_ARCHIVE after successful pivot'. Document in README.md: (1) Installation: 'pip install flashcore', (2) Usage examples with explicit db_path, (3) Architecture: Hub-and-Spoke model, (4) Dependency constraints (no torch/fsrs-optimizer), (5) Migration guide from old system. Update setup.py metadata. PRD Section 5 Verification Checklist: Confirm no heavy deps, pytest passes, CLI works with migrated data, images/audio load correctly.",
        "testStrategy": "Verify HPE_ARCHIVE/ does not exist in git tree. README.md contains installation, usage, and architecture sections. All PRD Section 5 checklist items pass.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-31T19:27:28.343Z",
      "updated": "2025-12-31T19:27:28.343Z",
      "description": "Tasks for master context"
    }
  }
}