{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Spoke Initialization & Structural Alignment",
        "description": "Align the existing boilerplate structure with setup.py requirements and define strict dependency constraints.",
        "details": "The directory 'flashcore-lib' already exists but must be renamed to 'flashcore' to match setup.py expectations (line 34: version=read('flashcore', 'VERSION')). Update requirements.txt to exclude torch/fsrs-optimizer and include only lightweight runtime dependencies: fsrs>=3.0.0, duckdb>=1.0.0, pydantic>=2.7.0, typer>=0.12.0, rich>=13.0.0, ruamel.yaml>=0.17.0. This enforces the 'Nuclear Reactor' fix from PRD Section 2.A.",
        "testStrategy": "Verify the repository structure and ensure all dependencies are correctly listed in pyproject.toml.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Rename Package Directory",
            "description": "Rename 'flashcore-lib' to 'flashcore' to match setup.py package name.",
            "dependencies": [],
            "details": "Execute: mv flashcore-lib flashcore. This fixes the mismatch where setup.py expects 'flashcore' (line 34) but the directory is named 'flashcore-lib'. CRITICAL: The template contains flashcore/cli.py, but the migrated implementation will use a flashcore/cli/ package. Remove or rename flashcore/cli.py after the move to avoid Python import collisions (module vs package).",
            "status": "done",
            "testStrategy": "Verify directory exists at ./flashcore/ and setup.py can read VERSION file.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enforce Dependency Constraints (Nuclear Reactor Fix)",
            "description": "Update requirements.txt to exclude heavy ML dependencies and include only lightweight runtime deps.",
            "dependencies": [
              "1"
            ],
            "details": "Edit requirements.txt to contain ONLY: duckdb>=1.0.0, pydantic>=2.7.0, fsrs>=3.0.0 (NOT fsrs-optimizer), typer>=0.12.0, rich>=13.0.0, ruamel.yaml>=0.17.0, PyYAML>=6.0.0, bleach>=6.0.0, tomli>=2.0.1; python_version<'3.11'. CRITICAL: Exclude torch, transformers, fsrs-optimizer per PRD Section 2.A. NOTE: PyYAML and bleach are required by the legacy YAML processing subsystem being ported (yaml_processor.py/yaml_models.py). Prefer to move the tomli environment marker into pyproject.toml dependencies once Task 1.3 establishes pyproject.toml as the single source of truth.",
            "status": "done",
            "testStrategy": "Run 'pip install -r requirements.txt' and verify no torch/transformers in dependency tree via 'pip list | grep torch'.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Establish Modern Build System and Deprecate Legacy Setup",
            "description": "Create pyproject.toml as single source of truth and deprecate setup.py.",
            "dependencies": [
              "2"
            ],
            "details": "Create pyproject.toml with [project] name='flashcore' and requires-python='>=3.10'. CRITICAL: Preserve VERSION-file semantics from setup.py (setup.py currently reads flashcore/VERSION). In pyproject.toml use setuptools dynamic version, e.g. [project] dynamic = ['version'] and [tool.setuptools.dynamic] version = {file = 'flashcore/VERSION'}. Define console entrypoint under [project.scripts] (e.g., flashcore = `flashcore.__main__:main`). CRITICAL: After creating pyproject.toml, rename setup.py to setup.py.bak or remove it entirely to prevent build tool confusion.",
            "status": "done",
            "testStrategy": "Validate with 'python -m build --sdist' and inspect generated metadata. Verify setup.py does not exist or is renamed to .bak.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify No Heavy Dependencies in Tree",
            "description": "Audit the full dependency tree to ensure no transitive heavy dependencies.",
            "dependencies": [
              "3"
            ],
            "details": "Run 'pip install -e .' then 'pip list' and verify total install size <50MB. Use 'pipdeptree' to check for torch/transformers in transitive deps.",
            "status": "done",
            "testStrategy": "PRD Section 5 Checklist Item 1: 'uv tree shows NO torch, transformers, or fsrs-optimizer'.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create .gitignore for Python Package",
            "description": "Add .gitignore to exclude build artifacts and virtual environments.",
            "dependencies": [
              "4"
            ],
            "details": "Create .gitignore with: `__pycache__/`, `*.pyc`, `*.pyo`, `*.egg-info/`, `dist/`, `build/`, `.venv/`, `.pytest_cache/`, `.coverage`.",
            "status": "done",
            "testStrategy": "Verify build artifacts are not tracked by git status.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-01T02:12:49.452Z"
      },
      {
        "id": "2",
        "title": "Migrate Core Data Models",
        "description": "Transfer and refactor core data models from HPE_ARCHIVE to the new library structure.",
        "details": "Copy HPE_ARCHIVE/flashcore/card.py to flashcore/models.py. This file contains Card, Review, Session, and CardState models using Pydantic v2. Remove all imports referencing `cultivation.scripts.flashcore` and replace with relative imports (e.g., 'from .db import ...'). Ensure Pydantic v2 syntax is maintained (Field, model_validate, model_dump). PRD Phase 2 Step 1.",
        "testStrategy": "Import models.py and instantiate Card/Review objects. Run 'python -c \"from flashcore.models import Card, Review, Session, CardState\"' to verify no import errors.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Copy card.py to models.py",
            "description": "Transfer the Card, Review, Session, and CardState models from HPE_ARCHIVE.",
            "dependencies": [],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/card.py flashcore/models.py. This is the foundation data layer.",
            "status": "done",
            "testStrategy": "Verify file exists at flashcore/models.py.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Remove Cultivation Import References",
            "description": "Replace absolute imports with relative imports for library portability.",
            "dependencies": [
              "1"
            ],
            "details": "Search for `from cultivation.scripts.flashcore` in models.py and replace with relative imports. Example: `from cultivation.scripts.flashcore.config import X` becomes `from .config import X` or remove if not needed.",
            "status": "done",
            "testStrategy": "Run 'grep -n cultivation flashcore/models.py' should return no results.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Verify Pydantic v2 Compatibility",
            "description": "Ensure all Pydantic models use v2 syntax (no deprecated v1 patterns).",
            "dependencies": [
              "2"
            ],
            "details": "Check for: Field() usage, model_validate() instead of parse_obj(), model_dump() instead of dict(). Verify ConfigDict is used instead of class Config.",
            "status": "done",
            "testStrategy": "Run models through pydantic validation: 'python -c \"from flashcore.models import Card; Card.model_validate({...})\"'.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Type Hints and Documentation",
            "description": "Ensure all models have complete type hints and docstrings.",
            "dependencies": [
              "3"
            ],
            "details": "Verify Card, Review, Session classes have docstrings explaining their purpose. Ensure all fields have type annotations.",
            "status": "done",
            "testStrategy": "Run mypy on models.py: 'mypy flashcore/models.py --strict'.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Extract FSRS Constants to constants.py",
            "description": "Transfer FSRS algorithm constants from HPE_ARCHIVE config.py.",
            "dependencies": [
              "4"
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/config.py flashcore/constants.py. CRITICAL: Remove Settings class and all path defaults (db_path, yaml_source_dir, assets_dir, export_dir, user_uuid) - these violate DI pattern. KEEP ONLY: DEFAULT_PARAMETERS (lines 58-80) and DEFAULT_DESIRED_RETENTION (line 83). Rename file to constants.py (not config.py) to accurately reflect content - this file contains static FSRS algorithm parameters, not runtime configuration. PURITY CONSTRAINT: Ensure constants.py does NOT import pydantic, pydantic_settings, os, or pathlib. It must be a pure Python file containing only native types (Tuple, float) to prevent circular imports during the O(1) scheduler refactor. Remove lines 4-8 (Path, uuid, pydantic_settings imports). Allowed imports: keep only `from typing import Tuple` (for DEFAULT_PARAMETERS signature) if used; remove all other imports.",
            "status": "done",
            "testStrategy": "Verify flashcore/constants.py exists and contains only DEFAULT_PARAMETERS and DEFAULT_DESIRED_RETENTION. Run 'grep -n Settings flashcore/constants.py' should return no results. Run 'grep -n import flashcore/constants.py' should show only 'from typing import Tuple' or no imports.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create `__init__.py` Exports",
            "description": "Expose models in `flashcore/__init__.py` for clean imports.",
            "dependencies": [
              "5"
            ],
            "details": "Add to `flashcore/__init__.py`: 'from .models import Card, Review, Session, CardState, ReviewRating'. This allows 'from flashcore import Card'.",
            "status": "done",
            "testStrategy": "Test import: 'python -c \"from flashcore import Card, Review\"'.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Migrate Model Tests (Incremental Verification)",
            "description": "Copy and adapt test_card.py to verify models work correctly.",
            "dependencies": [
              "6"
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_card.py tests/test_models.py. Update imports from `cultivation.scripts.flashcore.card` to `flashcore.models`. Verify Pydantic v2 validation works (model_validate, model_dump). Run 'pytest tests/test_models.py -v' - all tests should pass. This provides immediate safety net for model refactoring.",
            "status": "done",
            "testStrategy": "Run 'pytest tests/test_models.py -v' - all model tests pass. Verify Card, Review, Session instantiation and validation.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-01T02:57:55.499Z"
      },
      {
        "id": "3",
        "title": "Refactor Database Layer for Dependency Injection",
        "description": "Modify the database layer to eliminate hardcoded paths and enforce dependency injection.",
        "details": "Port the database subsystem from HPE_ARCHIVE into a flashcore/db/ package (NOT a single db.py). CRITICAL REFACTOR (PRD Section 2.B): FlashcardDatabase.`__init__` currently accepts Optional[db_path] and defaults to config.settings (line 44). Change signature to REQUIRE db_path: `def __init__(self, db_path: Union[str, Path], read_only: bool = False)`. Remove all references to config.settings. This enforces the 'Hardcoded Life' fix.",
        "testStrategy": "Instantiate FlashcardDatabase without db_path argument - should raise TypeError. Instantiate with explicit path - should succeed. Run: 'python -c \"from flashcore.db import FlashcardDatabase; FlashcardDatabase()\"' should fail.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Database Package Structure",
            "description": "Port database subsystem to flashcore/db/ package maintaining separation of concerns.",
            "dependencies": [],
            "details": "Create directory: mkdir -p flashcore/db. Copy modules: cp HPE_ARCHIVE/flashcore/database.py flashcore/db/database.py; cp HPE_ARCHIVE/flashcore/connection.py flashcore/db/connection.py; cp HPE_ARCHIVE/flashcore/schema_manager.py flashcore/db/schema_manager.py; cp HPE_ARCHIVE/flashcore/db_utils.py flashcore/db/db_utils.py; cp HPE_ARCHIVE/flashcore/schema.py flashcore/db/schema.py. Also copy shared exceptions: cp HPE_ARCHIVE/flashcore/exceptions.py flashcore/exceptions.py (required by DB + CLI). Create `flashcore/db/__init__.py` that exports ONLY: 'from .database import FlashcardDatabase' (keep other modules internal). This maintains architectural separation (focused modules) rather than creating a monolithic 1000+ line file.",
            "status": "done",
            "testStrategy": "Verify flashcore/db/ directory exists with 5 modules. Verify `flashcore/db/__init__.py` exports FlashcardDatabase (and does not re-export internal modules).",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T04:11:55.397Z"
          },
          {
            "id": 2,
            "title": "Remove config.settings Dependency",
            "description": "Eliminate all imports and references to config.settings from db package modules.",
            "dependencies": [
              "1"
            ],
            "details": "In flashcore/db/database.py line 44, `__init__` has 'db_path: Optional[Union[str, Path]] = None' and defaults to settings. Remove this default. In flashcore/db/connection.py line 6, remove 'from .config import settings' import and line 16 'self.db_path_resolved = settings.db_path'. The library must not know about config files.",
            "status": "done",
            "testStrategy": "Run 'grep -rn config flashcore/db/' should return no results.",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T04:11:55.443Z"
          },
          {
            "id": 3,
            "title": "Make db_path Required Argument",
            "description": "Change FlashcardDatabase.`__init__` signature to require db_path.",
            "dependencies": [
              "2"
            ],
            "details": "Change signature from `def __init__(self, db_path: Optional[Union[str, Path]] = None, ...)` to `def __init__(self, db_path: Union[str, Path], read_only: bool = False)`. Update docstring to reflect: db_path is required (no default), accepted types are Union[str, Path], path resolution expectations (cwd vs absolute), and that the path must be writable unless read_only=True.",
            "status": "done",
            "testStrategy": "Attempt to instantiate without argument: 'FlashcardDatabase()' should raise TypeError: missing required positional argument 'db_path'.",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T04:11:55.451Z"
          },
          {
            "id": 4,
            "title": "Update ConnectionHandler for DI",
            "description": "Ensure ConnectionHandler also requires db_path and doesn't default to config.",
            "dependencies": [
              "3"
            ],
            "details": "Review ConnectionHandler.`__init__` in connection.py. If it also has Optional db_path with config default, apply same refactor. Ensure it receives db_path from FlashcardDatabase.",
            "status": "done",
            "testStrategy": "Trace db_path flow: FlashcardDatabase -> ConnectionHandler -> duckdb.connect(). No config lookups in chain.",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T04:11:55.458Z"
          },
          {
            "id": 5,
            "title": "Add db Package to `__init__.py` Exports",
            "description": "Expose FlashcardDatabase from db package in `flashcore/__init__.py`.",
            "dependencies": [
              "4"
            ],
            "details": "Add to `flashcore/__init__.py`: 'from .db import FlashcardDatabase'. The `db/__init__.py` already exports FlashcardDatabase from .database, so this import works cleanly. This allows 'from flashcore import FlashcardDatabase'.",
            "status": "done",
            "testStrategy": "Test import and instantiation: 'python -c \"from flashcore import FlashcardDatabase; db = FlashcardDatabase(\\\"/tmp/test.db\\\")\"'.",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T04:11:55.460Z"
          },
          {
            "id": 6,
            "title": "Remove pandas Dependency from Database Layer",
            "description": "Refactor DB queries to avoid pandas (keep dependency footprint small).",
            "dependencies": [
              "5"
            ],
            "details": "HPE_ARCHIVE database layer uses DuckDB's fetch_df() which requires pandas. Refactor flashcore/db/database.py and flashcore/db/db_utils.py to avoid pandas entirely: replace fetch_df() calls with fetchall()/fetchone() and construct row dicts using cursor.description for column names. Remove any pandas imports/usages (e.g., pd.isna) and update marshalling accordingly.",
            "status": "done",
            "testStrategy": "Run 'python -c \"import flashcore; from flashcore.db import FlashcardDatabase\"' in an environment WITHOUT pandas installed; imports should succeed. Run DB unit tests after refactor.",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T04:11:55.461Z"
          },
          {
            "id": 7,
            "title": "Migrate Database Tests with DI Fixtures (Incremental Verification)",
            "description": "Copy and adapt test_database.py to verify DI refactoring works correctly.",
            "dependencies": [
              "6"
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_database.py tests/test_db.py. CRITICAL FIXTURE UPDATE: Replace all fixtures that use 'FlashcardDatabase()' with 'FlashcardDatabase(db_path=tmp_path / \"test.db\")'. Update conftest.py to provide tmp_path fixture. Update imports from `cultivation.scripts.flashcore` to `flashcore`. This verifies Dependency Injection works and provides safety net for DB refactoring. Also copy test_database_errors.py for error handling tests.",
            "status": "done",
            "testStrategy": "Run 'pytest tests/test_db.py -v' - all database tests pass with explicit db_path. Verify FlashcardDatabase() without args raises TypeError.",
            "parentId": "undefined",
            "updatedAt": "2026-01-03T04:11:55.463Z"
          }
        ],
        "updatedAt": "2026-01-03T04:11:55.463Z"
      },
      {
        "id": "4",
        "title": "Optimize Scheduler Logic (O(1) Performance Fix)",
        "description": "Eliminate the O(N) history replay bottleneck by using cached card state.",
        "details": "CRITICAL PERFORMANCE FIX (PRD Section 2 Finding 2): HPE_ARCHIVE/flashcore/scheduler.py lines 154-160 contain `for review in history: fsrs_card, _ = self.fsrs_scheduler.review_card(...)` - this replays ENTIRE history on every review (O(N) complexity). For a card with 500 reviews, this loops 500 times. SOLUTION: Change compute_next_state signature from 'compute_next_state(history: List[Review], ...)' to 'compute_next_state(card: Card, new_rating: int, ...)'. Initialize FSRSCard from card.stability, card.difficulty, card.state (cached values) instead of replaying history. This makes scheduling O(1).",
        "testStrategy": "Create card with 100 reviews. Time compute_next_state - should be <10ms regardless of history length. Compare before/after: old implementation time should scale with history length, new should be constant.",
        "priority": "critical",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Copy scheduler.py and Update Imports",
            "description": "Transfer the scheduler module from HPE_ARCHIVE and update imports to use constants.py.",
            "dependencies": [],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/scheduler.py flashcore/scheduler.py. This contains FSRS_Scheduler and BaseScheduler classes. CRITICAL: Update imports on lines 16-19 from `from cultivation.scripts.flashcore.config import DEFAULT_PARAMETERS, DEFAULT_DESIRED_RETENTION` to `from .constants import DEFAULT_PARAMETERS, DEFAULT_DESIRED_RETENTION`. This reflects the config.py â†’ constants.py rename for clarity.",
            "status": "done",
            "testStrategy": "Verify file exists at flashcore/scheduler.py. Run 'grep -n \"from.*constants import\" flashcore/scheduler.py' - should find import on line ~16.",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:45.701Z"
          },
          {
            "id": 2,
            "title": "Change compute_next_state Signature",
            "description": "Modify method to accept Card object instead of history list.",
            "dependencies": [
              "1"
            ],
            "details": "In scheduler.py line 147, change 'def compute_next_state(self, history: List[Review], new_rating: int, review_ts: datetime.datetime)' to 'def compute_next_state(self, card: Card, new_rating: int, review_ts: datetime.datetime)'. Update BaseScheduler abstract method signature too (line 53).",
            "status": "done",
            "testStrategy": "Verify signature matches: 'grep -A2 \"def compute_next_state\" flashcore/scheduler.py'.",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:46.044Z"
          },
          {
            "id": 3,
            "title": "Copy review_processor.py to flashcore/review_processor.py",
            "description": "Transfer the ReviewProcessor service module from HPE_ARCHIVE.",
            "dependencies": [
              "1"
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/review_processor.py flashcore/review_processor.py. Also port the dependent review/session services used by the CLI: cp HPE_ARCHIVE/flashcore/review_manager.py flashcore/review_manager.py; cp HPE_ARCHIVE/flashcore/session_manager.py flashcore/session_manager.py. CRITICAL: session_manager.py uses DuckDB fetch_df() (requires pandas). When porting, refactor session_manager.py to avoid fetch_df() and pandas usage, mirroring the DB-layer 'no pandas' constraint.",
            "status": "done",
            "testStrategy": "Verify file exists at flashcore/review_processor.py and contains ReviewProcessor class.",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:46.180Z"
          },
          {
            "id": 4,
            "title": "Remove History Replay Loop (O(N) -> O(1))",
            "description": "Delete the for loop that replays entire review history.",
            "dependencies": [
              "3"
            ],
            "details": "Delete the history replay logic in compute_next_state: the 'for review in history: ...' loop is the performance bottleneck. Ensure `fsrs_card = FSRSCard()` still exists exactly once in the O(1) implementation (either preserved outside the deleted block or re-added explicitly).",
            "status": "done",
            "testStrategy": "Verify no 'for review in history' loop exists in compute_next_state method.",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:46.197Z"
          },
          {
            "id": 5,
            "title": "Initialize FSRSCard from Cached Card State",
            "description": "Use card.stability, card.difficulty, card.state instead of replaying history.",
            "dependencies": [
              "4"
            ],
            "details": "Replace deleted loop with: 'fsrs_card = FSRSCard(); if card.state != CardState.New: fsrs_card.stability = card.stability; fsrs_card.difficulty = card.difficulty; fsrs_card.state = FSRSState(card.state.value); fsrs_card.due = card.next_due_date'. This initializes from cached state (O(1)). Validate that CardState values map correctly to FSRSState values; if they diverge, introduce an explicit CardState->FSRSState mapping function and add a test that covers all CardState variants.",
            "status": "done",
            "testStrategy": "Verify fsrs_card is initialized from card attributes, not history loop.",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:46.226Z"
          },
          {
            "id": 6,
            "title": "Update review_processor.py to Pass Card Object",
            "description": "Modify callers of compute_next_state to pass card instead of history.",
            "dependencies": [
              "5"
            ],
            "details": "In flashcore/review_processor.py (review_processor.py) line 103, change 'scheduler_output = self.scheduler.compute_next_state(history=review_history, ...)' to 'scheduler_output = self.scheduler.compute_next_state(card=card, ...)'. Remove history parameter.",
            "status": "done",
            "testStrategy": "Run tests to verify scheduler integration works with new signature.",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:46.249Z"
          },
          {
            "id": 7,
            "title": "Migrate Scheduler Tests with O(1) Benchmark (Incremental Verification)",
            "description": "Copy and adapt test_scheduler.py to verify O(1) optimization works correctly.",
            "dependencies": [
              "6"
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_scheduler.py tests/test_scheduler.py. Update imports from 'cultivation.scripts.flashcore' to 'flashcore'. CRITICAL: Add new benchmark test 'test_compute_next_state_is_constant_time' that creates cards with 1, 10, 100, 500 reviews and times compute_next_state for each. Prefer a relative assertion to avoid hardware dependence: assert time(500) < 2x time(1) (or similar constant-factor bound). This verifies the O(1) property without relying on absolute millisecond thresholds.",
            "status": "done",
            "testStrategy": "Run 'pytest tests/test_scheduler.py -v' - all tests pass. Run benchmark test - verify O(1) performance (constant time regardless of history length).",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:46.261Z"
          },
          {
            "id": 8,
            "title": "Preserve FSRS Parameter Override Support",
            "description": "Ensure FSRS_Scheduler can accept custom weight vectors at runtime (no forever-defaults trap).",
            "dependencies": [
              "1"
            ],
            "details": "HPE_ARCHIVE FSRS_Scheduler already supports injection via FSRSSchedulerConfig(parameters=..., desired_retention=...). When porting/optimizing, ensure this remains supported and is surfaced to the CLI (Task 6) so users can supply externally-optimized weights without fsrs-optimizer.",
            "status": "done",
            "testStrategy": "Instantiate scheduler with custom weights and verify PyFSRSScheduler is built with w=custom tuple.",
            "parentId": "undefined",
            "updatedAt": "2026-01-05T21:55:46.265Z"
          }
        ],
        "updatedAt": "2026-01-05T21:55:46.265Z"
      },
      {
        "id": "5",
        "title": "Refactor Parser Layer to be Stateless",
        "description": "Remove stateful logic from the parser and centralize deduplication checks.",
        "details": "STATELESS REFACTOR (PRD Section 2 Finding 3): HPE_ARCHIVE/flashcore/yaml_processing/yaml_processor.py line 40 contains 'self.seen_questions: Dict[str, Path] = {}' - this is ephemeral state that creates split-brain deduplication. The YAMLProcessor should be a pure function: File -> List[Card]. Remove self.seen_questions entirely. Move ALL deduplication logic to the CLI ingest command, which should query db.get_all_card_fronts_and_uuids() BEFORE processing to get authoritative list, then filter YAMLProcessor output against this list.",
        "testStrategy": "Instantiate YAMLProcessor, call process_file() twice on same file - should return identical results (no state carried between calls). Verify 'grep -n seen_questions flashcore/parser.py' returns no results.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Copy yaml_processor.py to flashcore/parser.py",
            "description": "Transfer the YAML processing module from HPE_ARCHIVE.",
            "dependencies": [],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/yaml_processing/yaml_processor.py flashcore/parser.py. Also copy the dependent files: HPE_ARCHIVE/flashcore/yaml_processing/yaml_models.py -> flashcore/yaml_models.py and HPE_ARCHIVE/flashcore/yaml_processing/yaml_validators.py -> flashcore/yaml_validators.py. Update imports inside these modules from `cultivation.scripts.flashcore.*` to `flashcore.*` (e.g., CardState and regex constants from models).",
            "status": "pending",
            "testStrategy": "Verify file exists at flashcore/parser.py.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Remove self.seen_questions State Variable",
            "description": "Delete the stateful seen_questions dictionary from YAMLProcessor.`__init__`.",
            "dependencies": [
              "1"
            ],
            "details": "In parser.py line 40, delete 'self.seen_questions: Dict[str, Path] = {}'. Also remove all references to self.seen_questions in _handle_processed_card method (lines 99-110). The parser should not track duplicates.",
            "status": "pending",
            "testStrategy": "Verify 'grep -n seen_questions flashcore/parser.py' returns no results.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add parser.py to `__init__.py` Exports",
            "description": "Expose YAMLProcessor in `flashcore/__init__.py`.",
            "dependencies": [
              "2"
            ],
            "details": "Add to `flashcore/__init__.py`: 'from .parser import YAMLProcessor, YAMLProcessorConfig'. This allows 'from flashcore import YAMLProcessor'.",
            "status": "pending",
            "testStrategy": "Test import: 'python -c \"from flashcore import YAMLProcessor\"'.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Migrate Parser Tests with Statelessness Verification (Incremental Verification)",
            "description": "Copy and adapt test_yaml_processor.py to verify parser is truly stateless.",
            "dependencies": [
              "3"
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_yaml_processor.py tests/test_parser.py. Update imports from 'cultivation.scripts.flashcore.yaml_processing' to 'flashcore.parser'. CRITICAL: Add new test 'test_parser_is_stateless' that instantiates YAMLProcessor, processes a file twice, and verifies identical output (no state carried between calls). Also test that processing file with duplicate fronts returns all cards (no internal filtering). This verifies stateless refactor works.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_parser.py -v' - all tests pass. Run statelessness test - verify parser has no memory between calls.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Migrate YAML Validator Tests",
            "description": "Copy and adapt test_yaml_validators.py to verify yaml_validators.py and yaml_models.py ports are correct.",
            "dependencies": [
              "4"
            ],
            "details": "Execute: cp HPE_ARCHIVE/tests/test_yaml_validators.py tests/test_yaml_validators.py. Update imports from 'cultivation.scripts.flashcore.yaml_processing.yaml_validators' to 'flashcore.yaml_validators' and from 'cultivation.scripts.flashcore.yaml_processing.yaml_models' to 'flashcore.yaml_models'.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_yaml_validators.py -v' - all validator tests pass.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "6",
        "title": "Develop CLI Package for flashcore",
        "description": "Reconstruct the CLI as a modular package maintaining separation of concerns.",
        "details": "Port HPE_ARCHIVE/flashcore/cli/ as flashcore/cli/ PACKAGE (not single file). HPE_ARCHIVE has 6 modules totaling 960 lines: main.py (382 lines - entry point), review_ui.py (93 lines - UI), `_review_logic.py` (28 lines), `_review_all_logic.py` (172 lines - multi-deck logic), `_vet_logic.py` (222 lines - YAML vet/formatting), `_export_logic.py` (63 lines). Preserve this modular structure to avoid creating a 'God Object'. CRITICAL (PRD Section 3.3): CLI must accept --db flag for database path (no defaults). The CLI is responsible for dependency injection - it receives paths from user and passes to library classes.",
        "testStrategy": "Run 'flashcore review --db=/tmp/test.db --deck=test' - should work. Run 'flashcore review' without --db - should show error requiring db path.",
        "priority": "medium",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CLI Package Structure",
            "description": "Set up flashcore/cli/ as a package with modular architecture.",
            "dependencies": [],
            "details": "Create directory: mkdir -p flashcore/cli. Copy modular structure: cp HPE_ARCHIVE/flashcore/cli/main.py flashcore/cli/main.py (entry point); cp HPE_ARCHIVE/flashcore/cli/review_ui.py flashcore/cli/review_ui.py (UI layer); cp `HPE_ARCHIVE/flashcore/cli/__init__.py` `flashcore/cli/__init__.py`. This preserves separation of concerns - main.py handles CLI routing, separate modules handle business logic. Update imports from `cultivation.scripts.flashcore` to `flashcore`.",
            "status": "pending",
            "testStrategy": "Verify flashcore/cli/ directory exists with main.py and `__init__.py`. Run 'python -m flashcore.cli.main --help' - should show commands.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Extract and Refactor Ingestion Logic with Authoritative Deduplication",
            "description": "Extract ingestion and upsert logic from legacy main.py and implement DB-based deduplication.",
            "dependencies": [
              "1"
            ],
            "details": "CRITICAL SOURCE CORRECTION: Ingestion logic is in HPE_ARCHIVE/flashcore/cli/main.py lines 65-161 (`_load_cards_from_source`, `_filter_new_cards`, `_execute_ingestion`, `_perform_ingestion_logic`). Create flashcore/cli/ingest.py module extracting these functions. REFACTOR DEDUPLICATION (from Task 5.3): Replace `_filter_new_cards` logic to call db.get_all_card_fronts_and_uuids() BEFORE YAMLProcessor, filter output against existing_fronts set, then upsert only new cards. NOTE: `_vet_logic.py` (222 lines) is for 'vet' command (validation/formatting), NOT ingestion - copy separately if vet command needed.",
            "status": "pending",
            "testStrategy": "Ingest same deck twice - second run should detect all cards as duplicates and insert 0 new cards. Verify db.get_all_card_fronts_and_uuids() called before processing.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Port Review Logic Modules",
            "description": "Copy review logic modules maintaining separation between orchestration and UI.",
            "dependencies": [
              "1"
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/cli/_review_logic.py flashcore/cli/_review_logic.py (28 lines - session orchestration); cp HPE_ARCHIVE/flashcore/cli/_review_all_logic.py flashcore/cli/_review_all_logic.py (172 lines - multi-deck logic). Update imports to `flashcore`. Wire up: FlashcardDatabase(db_path=args.db), FSRS_Scheduler, ReviewSessionManager. Pass all paths explicitly - no config.settings references. Connect to review_ui.py for presentation layer.",
            "status": "pending",
            "testStrategy": "Run 'flashcore review --db=/tmp/test.db --deck=test' - should start review session.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Port Export, Vet, and Stats Functionality",
            "description": "Copy remaining CLI modules for export, vet, and stats commands.",
            "dependencies": [
              "1"
            ],
            "details": "Execute: cp HPE_ARCHIVE/flashcore/cli/_export_logic.py flashcore/cli/_export_logic.py (63 lines - export functionality); cp HPE_ARCHIVE/flashcore/cli/_vet_logic.py flashcore/cli/_vet_logic.py (222 lines - YAML validation/formatting for 'vet' command, NOT ingestion). Add stats command logic to main.py (query database for card counts, review stats, due cards). Display with rich tables. Update all imports to `flashcore`.",
            "status": "pending",
            "testStrategy": "Run 'flashcore stats --db=/tmp/test.db' - should display deck statistics. Run 'flashcore vet' - should validate YAML files.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add CLI to `__main__.py` Entry Point",
            "description": "Wire CLI to package entry point for 'flashcore' command.",
            "dependencies": [
              "2",
              "3",
              "4"
            ],
            "details": "Update `flashcore/__main__.py` to import and run CLI app (e.g., from flashcore.cli.main import main). Since setup.py is deprecated (Task 1.3), define console entrypoint in pyproject.toml using [project.scripts] (e.g., flashcore = `flashcore.__main__:main`). Test that 'flashcore' command is available after install.",
            "status": "pending",
            "testStrategy": "After 'pip install -e .', run 'which flashcore' - should find command. Run 'flashcore --help' - should work.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "7",
        "title": "Migrate Integration and Architectural Regression Tests",
        "description": "Transfer integration tests and architectural regression tests to verify end-to-end functionality.",
        "details": "Since unit tests are now migrated incrementally (Tasks 2-5), this task focuses on: (1) CLI Integration Tests - copy HPE_ARCHIVE/tests/cli/ to tests/cli/ for end-to-end CLI command testing. (2) Architectural Regression Tests - copy test_rating_system_inconsistency.py, test_session_analytics_gaps.py, test_review_logic_duplication.py (PRD Section 4 Phase 2 Step 5 calls these 'high-value assets' documenting past flaws). (3) Service Layer Tests - copy test_review_processor.py, test_review_manager.py, test_session_manager.py. Update all imports from 'cultivation.scripts.flashcore' to 'flashcore'. Update fixtures to use explicit db_path.",
        "testStrategy": "Run 'pytest tests/ -v' - all tests pass including integration and regression tests. Verify test coverage >80% with 'pytest --cov=flashcore tests/'. Run CLI integration tests to verify end-to-end workflows.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Migrate CLI Integration Tests",
            "description": "Copy CLI integration tests to verify end-to-end command functionality.",
            "dependencies": [],
            "details": "Execute: cp -r HPE_ARCHIVE/tests/cli/ tests/cli/. These tests verify the full CLI workflow (ingest, review, stats commands). Update imports and ensure tests use explicit --db flags (no config.settings).",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/cli/ -v' - all CLI integration tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Migrate Architectural Regression Tests",
            "description": "Copy tests that document and prevent past architectural flaws.",
            "dependencies": [],
            "details": "Copy: test_rating_system_inconsistency.py, test_session_analytics_gaps.py, test_review_logic_duplication.py. PRD emphasizes these are 'invaluable architectural regression tests' that validate fixes for past bugs. Update imports to 'flashcore'.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_rating_system_inconsistency.py tests/test_session_analytics_gaps.py -v' - all regression tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Migrate Service Layer Tests",
            "description": "Copy tests for ReviewProcessor, ReviewManager, SessionManager.",
            "dependencies": [],
            "details": "Copy: test_review_processor.py, test_review_manager.py, test_session_manager.py, test_session_model.py. These test the service orchestration layer. Update imports to the new module layout: flashcore.review_processor, flashcore.review_manager, flashcore.session_manager.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/test_review_processor.py tests/test_review_manager.py -v' - all service tests pass.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Copy conftest.py and Shared Fixtures",
            "description": "Migrate shared test fixtures and configuration.",
            "dependencies": [
              "1",
              "2",
              "3"
            ],
            "details": "Copy HPE_ARCHIVE/tests/conftest.py to tests/conftest.py. Update fixtures to use explicit db_path (tmp_path / 'test.db') instead of config.settings. Ensure pytest configuration is correct.",
            "status": "pending",
            "testStrategy": "Run 'pytest tests/ --collect-only' - all tests discovered correctly with proper fixtures.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run Full Test Suite and Verify Coverage",
            "description": "Execute complete test suite and verify coverage meets PRD requirements.",
            "dependencies": [
              "4"
            ],
            "details": "Run 'pytest tests/ -v' to execute all tests (unit + integration + regression). Run 'pytest --cov=flashcore tests/' to verify >80% coverage. All tests should pass, proving the refactoring is correct and safe.",
            "status": "pending",
            "testStrategy": "All tests pass. Coverage >80%. No regressions detected.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "8",
        "title": "Implement Data Safety Strategy",
        "description": "Develop a strategy for safely migrating data from the old system to the new library.",
        "details": "PRD Section 4 Phase 3: Do NOT copy .db file directly (binary compatibility risk). Keep HPE_ARCHIVE as read-only reference. Instead: (1) Create export script flashcore/scripts/dump_history.py that connects directly to the OLD DB path (duckdb) and exports cards -> cards.json, reviews -> reviews.json (no imports from HPE_ARCHIVE required). (2) Create flashcore/scripts/migrate.py (utility folder, NOT core package) with import_from_json(cards_path, reviews_path, db_path) that recreates schema and inserts data. (3) Validation: Compare row counts between old and new DBs, plus integrity checks (relationships and value ranges).",
        "testStrategy": "Export from old DB using flashcore/scripts/dump_history.py, import to new DB using flashcore/scripts/migrate.py. Verify row counts: SELECT COUNT(*) FROM cards matches; SELECT COUNT(*) FROM reviews matches. Relationship check: SELECT COUNT(*) FROM reviews r WHERE NOT EXISTS (SELECT 1 FROM cards c WHERE c.uuid = r.card_uuid); expected 0. Range check (example): SELECT COUNT(*) FROM cards WHERE state != 'New' AND (stability IS NULL OR stability <= 0); expected 0. Spot-check card UUIDs exist in both DBs.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create dump_history.py Export Script",
            "description": "Export cards and reviews from the legacy DB into JSON files.",
            "dependencies": [],
            "details": "Create flashcore/scripts/dump_history.py. It must connect directly to the old DuckDB file path and export cards -> cards.json, reviews -> reviews.json. Do not import anything from HPE_ARCHIVE.",
            "status": "pending",
            "testStrategy": "Run export and verify output JSON files exist and are parseable (python -c 'import json; json.load(open(...))').",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create migrate.py Import Utility",
            "description": "Import cards/reviews JSON into a new DB and recreate schema.",
            "dependencies": [
              "1"
            ],
            "details": "Create flashcore/scripts/migrate.py with import_from_json(cards_path, reviews_path, db_path). It recreates schema and inserts data.",
            "status": "pending",
            "testStrategy": "Run import into a fresh DB and verify tables exist and row counts are non-zero.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Migration Validation Queries",
            "description": "Validate migration completeness and integrity beyond simple row counts.",
            "dependencies": [
              "2"
            ],
            "details": "In addition to row count comparisons, run integrity checks: (1) Relationship validation: reviews must reference existing cards. (2) Value range validation: stability/difficulty values are within expected ranges. (3) Schema sanity: expected columns exist and are correct types.",
            "status": "pending",
            "testStrategy": "Verify relationship check returns 0 invalid rows; verify stability/difficulty checks return 0 invalid rows; verify schema contains expected columns.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "9",
        "title": "Finalize and Document Migration",
        "description": "Complete the migration process and document the new architecture and usage.",
        "details": "CRITICAL (PRD Section 4 Feature Branch Workflow): Remove HPE_ARCHIVE/ directory before final merge. Execute: 'git rm -r HPE_ARCHIVE/' and commit with message 'chore(repo): Remove HPE_ARCHIVE after successful pivot'. Document in README.md: (1) Installation: 'pip install flashcore', (2) Usage examples with explicit db_path, (3) Architecture: Hub-and-Spoke model, (4) Dependency constraints (no torch/fsrs-optimizer), (5) Migration guide from old system. Update pyproject.toml metadata (setup.py is deprecated/removed). PRD Section 5 Verification Checklist: Confirm no torch or fsrs-optimizer in pyproject.toml dependencies, pytest tests/ passes (all tests), flashcore CLI ingest/review/stats runs without error on migrated sample data, and assets referenced by YAML (images/audio) load correctly.",
        "testStrategy": "Verify HPE_ARCHIVE/ does not exist in git tree. README.md contains installation, usage, architecture, and migration guide sections. Confirm: (1) No torch/transformers/fsrs-optimizer in dependencies, (2) pytest tests/ passes, (3) flashcore CLI ingest/review/stats works on migrated sample data, (4) images/audio referenced in YAML load correctly.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove HPE_ARCHIVE Before Final Merge",
            "description": "Remove legacy archive directory to prevent dual source-of-truth confusion.",
            "dependencies": [],
            "details": "Execute: git rm -r HPE_ARCHIVE/ and commit with message 'chore(repo): Remove HPE_ARCHIVE after successful pivot'.",
            "status": "pending",
            "testStrategy": "Verify HPE_ARCHIVE/ is absent from git tree and repository root.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update README and Documentation",
            "description": "Document installation, usage, architecture, constraints, and migration guide.",
            "dependencies": [
              "1"
            ],
            "details": "Update README.md: installation, usage examples with explicit db_path, architecture (Hub-and-Spoke), dependency constraints (no torch/transformers/fsrs-optimizer), and migration guide.",
            "status": "pending",
            "testStrategy": "Verify README.md contains all required sections with runnable command examples.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Run Verification Checklist",
            "description": "Run PRD Section 5 verification checklist with explicit, testable criteria.",
            "dependencies": [
              "2"
            ],
            "details": "Confirm: (1) No torch/transformers/fsrs-optimizer in dependencies, (2) pytest tests/ passes, (3) flashcore CLI ingest/review/stats runs on migrated sample data, (4) assets referenced by YAML load correctly.",
            "status": "pending",
            "testStrategy": "All checklist items pass and are recorded in PR verification packet.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-05T21:55:46.268Z",
      "taskCount": 9,
      "completedCount": 4,
      "tags": [
        "master"
      ]
    }
  }
}